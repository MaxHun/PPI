%%% Copyright 2018 H.\ Rabus
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%%
%% This work has the LPPL maintenance status `author-maintained'.
%%
%% This work consists of the file texbsp.tex
%%
%
%\documentclass[smallheadings]{scrartcl}
%
%%%% GENERAL PACKAGES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% inputenc allows the usage of non-ascii characters in the LaTeX source code
%\usepackage[utf8]{inputenc}
%\usepackage{graphicx} 
%\usepackage{float}
%%\graphicspath{ {/u/hnatiuka/Praktikum/PPI/} }
%
%
%
%% title of the document
%\title{Schnittstellendokumentation}
%% optional subtitle
%%\subtitle{Draft from~\today}
%% information about the author
%\author{%
%  Arsen Hnatiuk,\\%
%  Max Huneshagen 
%}
%\date{\today} 
%
%
%%%% LANGUAGE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% babel provides hyphenation patterns and translations of keywords like 'table
%% of contents'
%\usepackage[ngerman]{babel}
%
%%%% HYPERLINKS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% automatic generation of hyperlinks for references and URIs
%\usepackage{hyperref}
%
%%%% MATH %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% amsmath provides commands for type-setting mathematical formulas
%\usepackage{amsmath}
%\numberwithin{equation}{section}
%% amssymb provides additional symbols
%\usepackage{amssymb}
%% HINT
%% Use http://detexify.kirelabs.org/classify.html to find unknown symbols!
%
%%%% COLORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% define own colors and use colored text
%\usepackage[pdftex,svgnames,hyperref]{xcolor}
%
%%%% Code Listings %%%%%%%%%%%%%%%%
%% provides commands for including code (python, latex, ...)
%\usepackage{listings}
%\definecolor{keywords}{RGB}{255,0,90}
%\definecolor{comments}{RGB}{0,0,113}
%\definecolor{red}{RGB}{160,0,0}
%\definecolor{green}{RGB}{0,150,0}
%\lstset{language=Python, 
%        basicstyle=\ttfamily\small, 
%        keywordstyle=\color{keywords},
%        commentstyle=\color{comments},
%        stringstyle=\color{red},
%        showstringspaces=false,
%        identifierstyle=\color{green},
%        }
%
%
%\usepackage{paralist}
%\usepackage{nicefrac}
%% setting the font style for input und returns in description items
%\newcommand{\initem}[2]{\item[\hspace{0.5em} {\normalfont\ttfamily{#1}} {\normalfont\itshape{(#2)}}]}
%\newcommand{\outitem}[1]{\item[\hspace{0.5em} \normalfont\itshape{(#1)}]}
%\newcommand{\bfpara}[1]{
%	
%	\noindent \textbf{#1:}\,}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Generated by Sphinx.
\def\sphinxdocclass{report}

\documentclass[letterpaper,10pt,ngerman, oneside, openright]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsngerman{\renewcommand{\contentsname}{Inhalt:}}

\addto\captionsngerman{\renewcommand{\figurename}{Abb.}}
\addto\captionsngerman{\renewcommand{\tablename}{Tab.}}
\addto\captionsngerman{\renewcommand{\literalblockname}{Quellcode}}

\addto\captionsngerman{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsngerman{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasngerman{\def\pageautorefname{Seite}}

\setcounter{tocdepth}{1}



\title{Serie 3 Schnittstellendokumentation}
\date{16.12.2018}
\release{}
\author{Arsen Hnatiuk, Max Huneshagen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\pagestyle{plain}
\usepackage{chngcntr}
\counterwithout{equation}{chapter}
\begin{document}

% generating the title page
\maketitle
% generating the table of contents (requires to run pdflatex twice!)
\tableofcontents
\bigskip

\hrule
\hrule

%%% BEGIN OF CONTENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Einleitung}

\section{Laplace Gleichung}
Die in dieser Serie implementierten Programme ermöglichen die Lösung des in Serie 2 betrachteten Gleichungssystems
\begin{align}
A^{(d)}\hat{u} = b,
\label{eq:glc}
\end{align}
wobei $A^{(d)}$ eine Bandmatrix der Dimension $d$ und $\hat{u}$ eine Approximation der Lösung der Laplace-Gleichung

\begin{align}
\begin{split}
-\Delta u&=f(x)\text{ in }\Omega=(0, 1)^d, d\in\{1,2,3\}\\
u \vert _{\partial\Omega}&=u_D\text{ für ein gegebenes }u_D.
\end{split}
\label{eq:rwp}
\end{align}


ist. $b$ ist der Vektor der Randbedingungen und der Werte der in der Laplace Gleichung gegebenen Funktion $f$ auf den in Serie 2 ausgewählten Punkten. Da alle Randbedingungen in dieser Serie $0$ sind, ist $b$ einfach der Vektor der $f_i := f(x_i)$ für die ausgewählten $x_i$. 

Die Lösung dieses Systems erfolgt durch die L-U-Zerlegung der $A^{(d)}$ Matrix. Wir können also $TA^{(d)}=LU$ für eine Permutationsmatrix $P$, eine unipotente untere Dreiecksmatrix $L$ und eine invertierbare obere Dreiecksmatrix $U$ schreiben. Dann lässt sich die Gleichung \ref{eq:glc} so darstellen:
\begin{align}
T^tLU\hat{u}=b
\label{eq:lu}
\end{align}
Man gewinnt die Werte von $\hat{u}$, indem man mittels Rückwärtssubstitution die Gleichung 
\begin{align}
T^tLz=b
\label{eq:lu1}
\end{align}
für ein $z\in \mathbb{R}^{(n-1)^d}$ löst. Dies ist möglich, weil $L$ eine Dreiecksmatrix mit Einsen auf der Hauptdiagonale ist. Die Werte von $\hat{u}$ rechnet man durch Rückwärtssubstitution in der Gleichung \eqref{eq:lu2} aus. Dies ist möglich, weil alle Hauptdiagonaleinträge von $R$ ungleich $0$ sind (dies sind die sogenannten Pivotelemente).
\begin{align}
R\hat{u}=z
\label{eq:lu2}
\end{align}
Wenn man die Gleichungen \eqref{eq:lu1} und \eqref{eq:lu2} zusammensetzt, so erhält man \eqref{eq:lu}.

\section{Hilbert-Matrizen}
Die erstellten Programme ermöglichen auch die Arbeit mit Hilbert-Matrizen. Diese dienen als Beispiel schlecht konditionierter Matrizen und sind wie folgt definiert:
\begin{align}
H_m &:= (a_{ij})_{1\le i, j \le m} \in \mathbb{R}^{m\times m}, 	\\
a_{ij} &:= \frac{1}{i+j-1} \label{eq:hb1}
\end{align}
Das Inverse einer Hilbert-Matrix ergibt sich zu:
\begin{align}
H_m^{-1}& := (b_{ij})_{1\le i, j \le m} \in \mathbb{R}^{m\times m},	\\
b_{ij} := \frac{(-1)^{i+j}}{i+j-1}\cdot &\frac{(m+i-1)!}{(i-1)!^2(m-i)!}\cdot \frac{(m+j-1)!}{(j-1)!^2(m-j)!}
\end{align}

Für die Kondition $\kappa$ einer Matrix $A$ gilt
\begin{align}
\kappa(A)=\|A\|\cdot \|A^{-1}\|
\end{align}
Wenn wir die Spaltensummennorm $\|\cdot \|_{\infty}$ benutzen, ist die hohe Kondition einer Hilbert-Matrix leicht zu sehen. Aus \eqref{eq:hb1}  sieht man, dass die erste Spalte von $H_m$ die höchste Spaltensumme hat, und es gilt
\begin{align}
\|H_m\|_{\infty}=\sum_{i=1}^{m}\frac{1}{i}
\end{align}
Diese Reihe divergiert. Die Einträge von $H_m^{-1}$ sind dabei sehr groß. Schon für $i=j=1$ gilt $bij = m^2$, also die Norm von dieser Matrix wächst mindestens quadratisch. Folglich ist die Kondition $\kappa(H_m)\gg1$ für $m>1$.

\chapter{Die Sparse-Klasse}

\label{\detokenize{index:welcome-to-serie-3-s-documentation}}\label{\detokenize{index:module-sparse_erw}}\label{\detokenize{index:die-sparse-klasse}}\index{sparse\_erw (Modul)}
\textit{sparse\_erw.py} stellt eine erweiterte Version der  Klasse \textit{Sparse} zur Verfügung, mit der die Matrix $A^{(d)}$ für $d\in\{1,2,3\}$
bestimmt und analysiert werden kann.
\index{Sparse (Klasse in sparse\_erw)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{sparse\_erw.}\sphinxbfcode{Sparse}}{\emph{dim}, \emph{dis}, \emph{r\_s=None}, \emph{ex\_lsg=None}}{}
Diese Klasse erlaubt das Erstellen der Matrizen $A^{(d)}$ für $d \in \{1,2,3\}$. Diese Matrizen werden
z. B. fuer die Berechnung der DGL $u''(x)=-f(x)$ verwendet. Es handelt sich bei diesen Matrizen
um sehr dünn besetzte Block-Band-Matrizen, was die Verwendung von sog. sparse-Matrizen
in der numerischen Umsetzung nahelegt.

Attribute:
\begin{quote}
\begin{description}
\item[{dim (int):}] \leavevmode
Raumdimension des zu untersuchenden Gebietes.

\item[{dis (numpy.ndarray aus floats):}] \leavevmode
Maß für die Diskretisierung des zu untersuchenden Gebietes.

\item[{matr (scipy.dok\_matrix-Objekt):}] \leavevmode
$A^{(d)}$ mit Diskretisierung dis.

\end{description}
\end{quote}
\index{anz\_n\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_abs}}{}{}
Gibt die Anzahl von Einträgen von $A^{(d)}$ zurück, die gleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}

\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Anzahl von Nulleinträgen von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_n\_lu\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_lu_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_lu\_abs}}{}{}
Gibt die Anzahl von Einträgen von $L$ bzw. $U$ zurück, die gleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Anzahl von Nulleinträgen von $L$ und $U$.

\end{description}

\end{description}

\end{fulllineitems}
\clearpage
\index{anz\_n\_lu\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_lu_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_lu\_rel}}{}{}
Gibt die relative Anzahl von Einträgen von L bzw. U zurück, die gleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Relative Anzahl von Nulleinträgen von $L$ und $U$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_n\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_rel}}{}{}
Gibt die relative Anzahl von Einträgen von $A^{(d)}$ zurück, die gleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Relative Anzahl von Nulleinträgen von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_abs}}{}{}
Gibt die Anzahl von Einträgen von $A^{(d)}$ zurück, die ungleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Anzahl von Nichtnulleinträgen von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_lu\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_lu_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_lu\_abs}}{}{}
Gibt die Anzahl von Einträgen von L bzw. U zurück, die ungleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Anzahl von Nichtnulleinträgen von L und U.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_lu\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_lu_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_lu\_rel}}{}{}
Gibt die relative Anzahl von Einträgen von L bzw. U zurück, die ungleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Relative Anzahl von Nulleinträgen von L und U.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_rel}}{}{}
Gibt die relative Anzahl von Einträgen von $A^{(d)}$ zurück, die ungleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Relative Anzahl von Nulleinträgen von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}
\clearpage
\index{constr\_mat\_l\_k() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.constr_mat_l_k}}\pysiglinewithargsret{\sphinxbfcode{constr\_mat\_l\_k}}{\emph{k}, \emph{dim}, \emph{dis}}{}
Konstruiert die Matrix $A_l(k)$ mit der gewünschten Diskretisierung.

\begin{description}
\item [{Input:}] \leavevmode

\begin{quote}
\begin{description}
\item[{k (float):}] \leavevmode
Bestimmt den Wert auf der Hauptdiagonalen der untersuchten Matrix (=2*k)

\item[{dim (int, mögliche Werte: 1, 2, 3):}] \leavevmode
Raumdimension des betrachteten Gebietes.

\item[{dis (int):}] \leavevmode
Diskretisierung des Gebietes.

\end{description}
\end{quote}
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
A\_l(k) mit der gewuenschten Diskretisierung.

\end{description}

\end{description}

\end{fulllineitems}

\index{kond\_a\_d\_zs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.kond_a_d_zs}}\pysiglinewithargsret{\sphinxbfcode{kond\_a\_d\_zs}}{}{}
Gibt die Kondition der Matrix $A^{(d)}$ bezüglich der Zeilensummennorm zurück.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Kondition von $A^{(d)}$ bzgl. Zeilennorm.

\end{description}

\end{description}

\end{fulllineitems}

\index{l\_u\_zerl() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.l_u_zerl}}\pysiglinewithargsret{\sphinxbfcode{l\_u\_zerl}}{}{}
Errechnet die L-U-Zerlegung von $A^{(d)}=P_r^TLUP_c^T$.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(list):}] \leavevmode
Nullter Eintrag: das mit der Zerlegung korrespondierende \textit{scipy.SuperLU}-Objekt.
Erster Eintrag: Tripel aus den Matrizen $P_r$, $P_c$, $L$, $U$.

\end{description}

\end{description}

\end{fulllineitems}

\index{lgs\_lsg() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.lgs_lsg}}\pysiglinewithargsret{\sphinxbfcode{lgs\_lsg}}{\emph{r\_s=None}}{}~%\begin{quote}

Löst das Gleichungssystem Ax=r\_s für eine vorgebene rechte Seite unter Ausnutzung der
Dreieckszerlegung.

\begin{description}
\item [{Input:}]

\begin{quote}
\begin{description}
\item[{r\_s (numpy.ndarray):}] \leavevmode
rechte Seite b des zu lösenden Gleichungssystems $A^{(d)}$*x=b.

\end{description}
\end{quote}\end{description}
%\end{quote}

\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(numpy.ndarray):}] \leavevmode
Lösungsvektor.

\end{description}

\end{description}

\end{fulllineitems}

\index{return\_mat\_d() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d}}{}{}
Diese Methode gibt die Matrix $A^{(d)}$ as sparse-Matrix zurück.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
Die Matrix $A^{(d)}$ als sparse-Matrix.

\end{description}

\end{description}

\end{fulllineitems}
\clearpage
\index{return\_mat\_d\_csc() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d_csc}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d\_csc}}{}{}
Gibt $A^{(d)}$ als scipy.sparse.csc\_matrix-Objekt zurück.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.csc\_matrix-Objekt)}] \leavevmode
Die Matrix $A^{(d)}$

\end{description}

\end{description}

\end{fulllineitems}

\index{return\_mat\_d\_inv() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d_inv}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d\_inv}}{}{}
Gibt die numerisch berechnete Inverse von $A^{(d)}$ zurück.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
Inverse von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\chapter{Die Skripte \textit{aufg\_3\_2u3\_main.py} und \textit{aufg\_3\_4\_main.py}}

Die Aufgaben 3.2 bis 3.4 der Aufgabenstellungen werden in den Skripten \textit{aufg\_3\_2u3\_main.py} und \textit{aufg\_3\_4\_main.py} bearbeitet. Für Aufgabe~3.2 wurde die numerische Näherung der Laplace-Gleichung \eqref{eq:glc} auf dem $d$-dimensionalen Einheitswürfel bestimmt. Das Ergebnis wird beim Ausführen von \textit{aufg\_3\_2u3\_main.py} graphisch dargestellt. Zusätzlich kann die numerische Lösung mit einer bekannten exakten lösung verglichen werden.

Mit Skript \textit{aufg\_3\_4\_main.py} werden die Band- und Hilbertmatrix bezüglich ihrer Kondition untersucht. Die graphische Darstellung zeigt, dass für ein festes $m$ gilt, dass $\kappa(A^{(1)})>\kappa(A^{(2)})>\kappa(A^{(3)})$. Die Kondition der Hilbertmatrix ist indes um viele Größenordnungen größer als die der betrachteten Bandmatrizen und wächst exponentiell mit $m$ (Gerade im einfach logarithmischen Plot). Des Weiteren wurde die Anzahl der Nichtnulleinträge der Bandmatrizen und ihrer L-U-Zerlegung untersucht. Dabei ist zu erkennen, dass die Matrizen $L$ und $U$ relativ dicht besetzt sind und wenig Nulleinträge haben im Vergleichh zur Ausgangsmatrix $A^{(d)}$, was die Verwendung der L-U-Zerlegung bei sehr großen $m$ hier sehr unpraktikabel macht. \textit{aufg\_3\_4\_main.py}  enthält ebenfalls die Funktionen \textit{plot\_fehl} und \textit{plot\_res}, die den Fehler $|\lvert x-x^\star|\rvert_\infty$ mit einer bekannten Referenzlösung $x^\star$ bzw. das Residuum $|\lvert Mx-b|\rvert_\infty$ mit $M\in \{A^{(1)},A^{(1)},A^{(1)}, H_m\}$ gegen $m$ plotten. Diese werden in zukünftigen Aufgaben benötigt.

~\\
\emph{Bemerkung:} Da in der Aufgabenstellung explizit angegeben wurde, in welche Arten von sparse-Matrizentypen die Matrix $A^{(d)}$ umgewandelt werden kann und sich darunter nicht der Typ \textit{lil\_matrix} befand, wurde das \textit{SparseEfficiencyWarning} beim Ausführen von \textit{aufg\_3\_4\_main.py} ignoriert, weil es sich nur durch die Umwandlung in eine \textit{lil\_matrix} direkt umgehen lässt. Das Aufkommen eines weiteren \textit{SparseEfficiencyWarning} könnte durch die Umwandlung von $b$ in ein \textit{csc\_matrix}-Objekt verhindert werdenn (s.~doppelt auskommentierter Teil im Quellcode), da $b$ aber i.\,A. dicht besetzt ist, wird darauf verzichtet.



%%% END OF DOCUMENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
