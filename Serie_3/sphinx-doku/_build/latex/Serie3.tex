%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,ngerman]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsngerman{\renewcommand{\contentsname}{Contents:}}

\addto\captionsngerman{\renewcommand{\figurename}{Abb.}}
\addto\captionsngerman{\renewcommand{\tablename}{Tab.}}
\addto\captionsngerman{\renewcommand{\literalblockname}{Quellcode}}

\addto\captionsngerman{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsngerman{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasngerman{\def\pageautorefname{Seite}}

\setcounter{tocdepth}{1}



\title{Serie 3 Documentation}
\date{02.01.2019}
\release{}
\author{Arsen Hnatiuk, Max Huneshagen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}
\ifnum\catcode`\"=\active\shorthandoff{"}\fi
\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Die Sparse-Klasse}
\label{\detokenize{index:module-sparse_erw}}\label{\detokenize{index:die-sparse-klasse}}\label{\detokenize{index:welcome-to-serie-3-s-documentation}}\index{sparse\_erw (Modul)}
sparse.py stellt die Klasse Sparse zur Verfuegung, mit der die Matrix A\textasciicircum{}(d) fuer d=1,2,3
bestimmt und analysiert werden kann.
\index{Sparse (Klasse in sparse\_erw)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{sparse\_erw.}\sphinxbfcode{Sparse}}{\emph{dim}, \emph{dis}}{}
Diese Klasse erlaubt das Erstellen der Matrizen A\textasciicircum{}(d) fuer d in {[}1,2,3{]}. Diese Matrizen werden
z. B. fuer die Berechnung der DGL u‘‚(x)=-f(x) verwendet. Es handelt sich bei diesen Matrizen
um sehr duenn besetzte Block-Band-Matrizen, was die Verwendung von sog. sparse-Matrizen
in der numerischen Umsetzung nahelegt.

Attribute:
\begin{quote}
\begin{description}
\item[{dim (int):}] \leavevmode
Raumdimension des zu untersuchenden Gebietes.

\item[{dis (numpy.ndarray aus floats):}] \leavevmode
Mass fuer die Diskretisierung des zu untersuchenden Gebietes.

\item[{matr (scipy.dok\_matrix-Objekt):}] \leavevmode
A\textasciicircum{}(d) mit Diskretisierung dis.

\end{description}
\end{quote}
\index{anz\_n\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_abs}}{}{}
Gibt die Anzahl von Eintraegen von A\textasciicircum{}(d) zurueck, die gleich 0 sind.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Anzahl von Nulleintraegen von A\textasciicircum{}(d).

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_n\_lu\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_lu_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_lu\_abs}}{}{}
Gibt die Anzahl von Eintraegen von L bzw. U zurueck, die gleich 0 sind.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Anzahl von Nulleintraegen von L und U.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_n\_lu\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_lu_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_lu\_rel}}{}{}
Gibt die relative Anzahl von Eintraegen von L bzw. U zurueck, die gleich 0 sind.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Relative Anzahl von Nulleintraegen von L und U.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_n\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_rel}}{}{}
Gibt die relative Anzahl von Eintraegen von A\textasciicircum{}(d) zurueck, die gleich 0 sind.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Relative Anzahl von Nulleintraegen von A\textasciicircum{}(d).

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_abs}}{}{}
Gibt die Anzahl von Eintraegen von A\textasciicircum{}(d) zurueck, die ungleich 0 sind.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Anzahl von Nicht-Nulleintraegen von A\textasciicircum{}(d).

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_lu\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_lu_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_lu\_abs}}{}{}
Gibt die Anzahl von Eintraegen von L bzw. U zurueck, die ungleich 0 sind.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Anzahl von Nicht-Nulleintraegen von L und U.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_lu\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_lu_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_lu\_rel}}{}{}
Gibt die relative Anzahl von Eintraegen von L bzw. U zurueck, die ungleich 0 sind.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Relative Anzahl von Nulleintraegen von L und U.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_rel}}{}{}
Gibt die relative Anzahl von Eintraegen von A\textasciicircum{}(d) zurueck, die ungleich 0 sind.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Relative Anzahl von Nulleintraegen von A\textasciicircum{}(d).

\end{description}

\end{description}

\end{fulllineitems}

\index{constr\_mat\_l\_k() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.constr_mat_l_k}}\pysiglinewithargsret{\sphinxbfcode{constr\_mat\_l\_k}}{\emph{k}, \emph{dim}, \emph{dis}}{}
Konstruiert die Matrix A\_l(k) mit der gewuenschten Diskretisierung.

Input:
\begin{quote}
\begin{description}
\item[{k (float):}] \leavevmode
Bestimmt den Wert auf der Hauptdiagonalen der untersuchten Matrix (=2*k)

\item[{dim (int, moegliche Werte: 1, 2, 3):}] \leavevmode
Raumdimension des betrachteten Gebietes.

\item[{dis (int):}] \leavevmode
Diskretisierung des Gebietes.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
A\_l(k) mit der gewuenschten Diskretisierung.

\end{description}

\end{description}

\end{fulllineitems}

\index{kond\_a\_d\_zs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.kond_a_d_zs}}\pysiglinewithargsret{\sphinxbfcode{kond\_a\_d\_zs}}{}{}
Gibt die Kondition der Matrix A\textasciicircum{}(d) bezueglich der Zeilensummennorm zurueck.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Kondition von A\textasciicircum{}(d) bzgl. Zeilennorm.

\end{description}

\end{description}

\end{fulllineitems}

\index{l\_u\_zerl() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.l_u_zerl}}\pysiglinewithargsret{\sphinxbfcode{l\_u\_zerl}}{}{}
Errechnet die L-U-Zerlegung von A\textasciicircum{}(d)=P\_r\textasciicircum{}T*L*U*P\_c\textasciicircum{}T

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(list):}] \leavevmode
Nullter Eintrag: das mit der Zerlegung korrespondierende scipy.SuperLU-Objekt.
Erster Eintrag: Tripel aus den Matrizen P\_r, P\_c, L, U.

\end{description}

\end{description}

\end{fulllineitems}

\index{lgs\_lsg() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.lgs_lsg}}\pysiglinewithargsret{\sphinxbfcode{lgs\_lsg}}{\emph{r\_s}}{}~\begin{quote}

Loest das Gleichungssystem Ax=r\_s fuer eine vorgebene rechte Seite unter Ausnutzung der
Dreieckszerlegung.

Input:
\begin{quote}
\begin{description}
\item[{r\_s (numpy.ndarray):}] \leavevmode
rechte Seite b des zu loesenden Gleichungssystems A\textasciicircum{}(d)*x=b.

\end{description}
\end{quote}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(numpy.ndarray):}] \leavevmode
Loesungsvektor.

\end{description}

\end{description}

\end{fulllineitems}

\index{return\_mat\_d() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d}}{}{}
Diese Methode gibt die Matrix A\textasciicircum{}(d) as sparse-Matrix zurueck.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
Die Matrix A\textasciicircum{}(d) als sparse-Matrix.

\end{description}

\end{description}

\end{fulllineitems}

\index{return\_mat\_d\_csc() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d_csc}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d\_csc}}{}{}
Gibt A\textasciicircum{}(d) als scipy.sparse.csc\_matrix-Objekt zurueck.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.csc\_matrix-Objekt)}] \leavevmode
Die Matrix A\textasciicircum{}(d)

\end{description}

\end{description}

\end{fulllineitems}

\index{return\_mat\_d\_inv() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d_inv}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d\_inv}}{}{}
Gibt die numerisch berechnete Inverse von A\textasciicircum{}(d) zurueck.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
Inverse von A\textasciicircum{}(d).

\end{description}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-hilbertmatr}}\index{hilbertmatr (Modul)}
hilbertmatr.py stellt die Klasse Hilbert zur Verfuegung, mit der die Hilbertmatrix bestimmt und
analysiert werden kann.
\index{Hilbert (Klasse in hilbertmatr)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{hilbertmatr.}\sphinxbfcode{Hilbert}}{\emph{dim}, \emph{r\_s=None}}{}
Diese Klasse stellt Hilbert-Matrizen zur Verfuegung.

Attribute:
\begin{quote}
\begin{description}
\item[{dim (int):}] \leavevmode
Dimension der Matrix.

\end{description}
\end{quote}
\index{kond\_hil\_zs() (Methode von hilbertmatr.Hilbert)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert.kond_hil_zs}}\pysiglinewithargsret{\sphinxbfcode{kond\_hil\_zs}}{}{}
Gibt die Kondition der Matrix bezueglich der Zeilensummennorm zurueck.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Kondition der Hilbertmatrix.

\end{description}

\end{description}

\end{fulllineitems}

\index{l\_u\_zerl() (Methode von hilbertmatr.Hilbert)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert.l_u_zerl}}\pysiglinewithargsret{\sphinxbfcode{l\_u\_zerl}}{}{}
Errechnet die L-U-Zerlegung von A\textasciicircum{}(d)=P*L*U.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(Tripel aus numpy.ndarrays):}] \leavevmode
Die Matrizen P, L, U.

\end{description}

\end{description}

\end{fulllineitems}

\index{lgs\_lsg() (Methode von hilbertmatr.Hilbert)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert.lgs_lsg}}\pysiglinewithargsret{\sphinxbfcode{lgs\_lsg}}{\emph{r\_s=None}}{}
Loest das Gleichungssystem Ax=r\_s fuer eine vorgebene rechte Seite unter Ausnutzung der
Dreieckszerlegung.

Input: -
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(numpy.ndarray)}] \leavevmode
rechte Seite des Gleichungssystems Ax=r\_s.

\end{description}

\end{description}

\end{fulllineitems}

\index{return\_hil\_matr() (Methode von hilbertmatr.Hilbert)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert.return_hil_matr}}\pysiglinewithargsret{\sphinxbfcode{return\_hil\_matr}}{\emph{inv=False}}{}
Gibt die Hilbertmatrix oder ihr Inverses zurueck.

Input:
\begin{quote}
\begin{description}
\item[{inv (bool, Standard: False)}] \leavevmode
Gibt ann, ob Hilbertmatrix (False) oder ihr Inverses (True) ausgegeben wird.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(numpy.ndarray):}] \leavevmode
Hilbertmatrix oder ihr Inverses, falls inv == True.

\end{description}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-aufg_3_4_main}}\index{aufg\_3\_4\_main (Modul)}
Dieses Skript stellt die Loesung zu Aufgabe 3.4 dar, bei der es vor allem um die Analyse
der beiden zuvor bahndelten Matrizentypen und deren Fehleranfaelligkeit geht.
\index{plot\_fehl() (im Modul aufg\_3\_4\_main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_3_4_main.plot_fehl}}\pysiglinewithargsret{\sphinxcode{aufg\_3\_4\_main.}\sphinxbfcode{plot\_fehl}}{\emph{plotber}, \emph{r\_s\_arr}, \emph{ex\_lsg\_arr}, \emph{matr\_type}, \emph{dim=1}}{}
Plottet den Fehler der numerischen Loesung im Vergleich zur exakten Loesung.
\begin{description}
\item[{Input:}] \leavevmode\begin{description}
\item[{plotber (axis-Objekt):}] \leavevmode
Plotbereich, in den geplottet werden soll

\item[{r\_s\_arr (list oder array aus numpy.ndarrays):}] \leavevmode
Liste aus rechten Seiten.

\item[{ex\_lsg\_arr (list oder array aus numpy.ndarrays):}] \leavevmode
Liste aus entsprechenden exakten Loesungen.

\item[{matr\_type (string):}] \leavevmode
Bestimmt die Matrixart, die untersucht wird.
Moeglichkeiten: Hilbertmatrix („hil“) oder
Bandmatrix fuer d=1,2,3 („a“).

\item[{dim (int, Standard: 1):}] \leavevmode
Wird nur fuer die Bandmatrizen benoetigt und gibt deren Dimension an.

\end{description}

\end{description}

\end{fulllineitems}

\index{plot\_kond() (im Modul aufg\_3\_4\_main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_3_4_main.plot_kond}}\pysiglinewithargsret{\sphinxcode{aufg\_3\_4\_main.}\sphinxbfcode{plot\_kond}}{\emph{plotber}, \emph{m\_max}, \emph{matr\_type}}{}
Plottet die Kondition der Bandmatrizen bzw. der Hilbert-Matrix in Abhaengigkeit von der
Matrixgroesse m.

Input:
\begin{quote}
\begin{description}
\item[{plotber (axis-Objekt):}] \leavevmode
Plotbereich, in den geplottet werden soll

\item[{m\_max (int):}] \leavevmode
Maximale Matrixgroesse.

\item[{matr\_type (string):}] \leavevmode
Bestimmt die Matrixart, die untersucht wird.
Moeglichkeiten: Hilbertmatrix („hil“) oder
Bandmatrix fuer d=1,2,3 („a“).

\end{description}
\end{quote}

\end{fulllineitems}

\index{plot\_nn() (im Modul aufg\_3\_4\_main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_3_4_main.plot_nn}}\pysiglinewithargsret{\sphinxcode{aufg\_3\_4\_main.}\sphinxbfcode{plot\_nn}}{\emph{plotber}, \emph{m\_max}}{}
Plottet die (absolute) Anzahl der Nichtnulleintraege der Koeffizientenmatrix A\textasciicircum{}(d)

Input:
\begin{quote}
\begin{description}
\item[{plotber (axis-Objekt):}] \leavevmode
Plotbereich, in den geplottet werden soll

\item[{m\_max (int):}] \leavevmode
Maximale Matrixgroesse.

\end{description}
\end{quote}

\end{fulllineitems}

\index{plot\_res() (im Modul aufg\_3\_4\_main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_3_4_main.plot_res}}\pysiglinewithargsret{\sphinxcode{aufg\_3\_4\_main.}\sphinxbfcode{plot\_res}}{\emph{plotber}, \emph{r\_s\_arr}, \emph{matr\_type}, \emph{dim=1}}{}
Plottet das  Resiuduum.
\begin{description}
\item[{Input:}] \leavevmode\begin{description}
\item[{plotber (axis-Objekt):}] \leavevmode
Plotbereich, in den geplottet werden soll

\item[{r\_s\_arr (list oder array aus numpy.ndarrays):}] \leavevmode
Liste aus rechten Seiten.

\item[{matr\_type (string):}] \leavevmode
Bestimmt die Matrixart, die untersucht wird.
Moeglichkeiten: Hilbertmatrix („hil“) oder
Bandmatrix fuer d=1,2,3 („a“).

\item[{dim (int, Standard: 1):}] \leavevmode
Wird nur fuer die Bandmatrizen benoetigt und gibt deren Dimension an.

\end{description}

\end{description}

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-aufg_3_2u3_main}}\index{aufg\_3\_2u3\_main (Modul)}
Dieses Modul löst die Aufgaben 3.2 und 3.3, indem es die Differentialgleichung löst und
das Verhalten der Lösungen grafisch aufstellt.
\index{fntn() (im Modul aufg\_3\_2u3\_main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_3_2u3_main.fntn}}\pysiglinewithargsret{\sphinxcode{aufg\_3\_2u3\_main.}\sphinxbfcode{fntn}}{\emph{wert}}{}
Beispielfunktion
Input:
\begin{quote}
\begin{description}
\item[{wert (array von float):}] \leavevmode
Werte, auf dem die Funktion ausgewertet wird.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Wert der Funktion.

\end{description}

\end{description}

\end{fulllineitems}

\index{gitter() (im Modul aufg\_3\_2u3\_main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_3_2u3_main.gitter}}\pysiglinewithargsret{\sphinxcode{aufg\_3\_2u3\_main.}\sphinxbfcode{gitter}}{\emph{numb}, \emph{dims}}{}
Funktion, die für eine gegebene Dimension und Schrittweite eine Menge von Punkten erzeugt, auf
der die Differentialgleichung zu loesen ist.
Input:
\begin{quote}
\begin{description}
\item[{numb (int):}] \leavevmode
Feinheit der Diskretisierung

\item[{dims (int):}] \leavevmode
Dimension der Diskretisierung

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{arra (ndarray):}] \leavevmode
Array mit den Punkten auf dem Diskretisierungsgitter

\end{description}

\end{description}

\end{fulllineitems}

\index{loesg() (im Modul aufg\_3\_2u3\_main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_3_2u3_main.loesg}}\pysiglinewithargsret{\sphinxcode{aufg\_3\_2u3\_main.}\sphinxbfcode{loesg}}{\emph{numb}, \emph{dims}, \emph{fkt}, \emph{ulsg=\textless{}function fntn\textgreater{}}}{}
Diese Methode dient zur Lösung der Differentialgleichung und zum Vergleichen der exakten
und approximierten Lösungen.
Input:
\begin{quote}
\begin{description}
\item[{numb (int):}] \leavevmode
Feinheit der Diskretisierung.

\item[{dims (int):}] \leavevmode
Dimension der Diskretisierung.

\item[{fkt (Funktion):}] \leavevmode
Die gegebene Funktion f aus der Aufgabestellung.

\item[{ulsg (Funktion):}] \leavevmode
Die exakte Lösung der Differentialgleichung.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Der absolute Fehler in der approximierten Lösung der Differentialgleichung.

\end{description}

\end{description}

\end{fulllineitems}

\index{modo() (im Modul aufg\_3\_2u3\_main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_3_2u3_main.modo}}\pysiglinewithargsret{\sphinxcode{aufg\_3\_2u3\_main.}\sphinxbfcode{modo}}{\emph{m\_nb}, \emph{numb}}{}
Funktion, die die modifizierte Modolo-Methode aus dem Bericht zu Serie 2 implementiert
Input:
\begin{quote}
\begin{description}
\item[{m\_nb (int):}] \leavevmode
Zahl, für die wir den Wert der modifizierten Modolo Methode berechnen wollen

\item[{numb (int):}] \leavevmode
Feinheit der Diskretisierung

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Ausgabe der modifizierten Modolo Methode

\end{description}

\end{description}

\end{fulllineitems}



\renewcommand{\indexname}{Python-Modulindex}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\sphinxstyleindexentry{aufg\_3\_2u3\_main}}\sphinxstyleindexpageref{index:\detokenize{module-aufg_3_2u3_main}}
\item {\sphinxstyleindexentry{aufg\_3\_4\_main}}\sphinxstyleindexpageref{index:\detokenize{module-aufg_3_4_main}}
\indexspace
\bigletter{h}
\item {\sphinxstyleindexentry{hilbertmatr}}\sphinxstyleindexpageref{index:\detokenize{module-hilbertmatr}}
\indexspace
\bigletter{s}
\item {\sphinxstyleindexentry{sparse\_erw}}\sphinxstyleindexpageref{index:\detokenize{module-sparse_erw}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Stichwortverzeichnis}
\printindex
\end{document}