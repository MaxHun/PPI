%%% Copyright 2018 H.\ Rabus
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%%
%% This work has the LPPL maintenance status `author-maintained'.
%%
%% This work consists of the file texbsp.tex
%%
%
%\documentclass[smallheadings]{scrartcl}
%
%%%% GENERAL PACKAGES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% inputenc allows the usage of non-ascii characters in the LaTeX source code
%\usepackage[utf8]{inputenc}
%\usepackage{graphicx} 
%\usepackage{float}
%%\graphicspath{ {/u/hnatiuka/Praktikum/PPI/} }
%
%
%
%% title of the document
%\title{Schnittstellendokumentation}
%% optional subtitle
%%\subtitle{Draft from~\today}
%% information about the author
%\author{%
%  Arsen Hnatiuk,\\%
%  Max Huneshagen 
%}
%\date{\today} 
%
%
%%%% LANGUAGE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% babel provides hyphenation patterns and translations of keywords like 'table
%% of contents'
%\usepackage[ngerman]{babel}
%
%%%% HYPERLINKS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% automatic generation of hyperlinks for references and URIs
%\usepackage{hyperref}
%
%%%% MATH %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% amsmath provides commands for type-setting mathematical formulas
%\usepackage{amsmath}
%\numberwithin{equation}{section}
%% amssymb provides additional symbols
%\usepackage{amssymb}
%% HINT
%% Use http://detexify.kirelabs.org/classify.html to find unknown symbols!
%
%%%% COLORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% define own colors and use colored text
%\usepackage[pdftex,svgnames,hyperref]{xcolor}
%
%%%% Code Listings %%%%%%%%%%%%%%%%
%% provides commands for including code (python, latex, ...)
%\usepackage{listings}
%\definecolor{keywords}{RGB}{255,0,90}
%\definecolor{comments}{RGB}{0,0,113}
%\definecolor{red}{RGB}{160,0,0}
%\definecolor{green}{RGB}{0,150,0}
%\lstset{language=Python, 
%        basicstyle=\ttfamily\small, 
%        keywordstyle=\color{keywords},
%        commentstyle=\color{comments},
%        stringstyle=\color{red},
%        showstringspaces=false,
%        identifierstyle=\color{green},
%        }
%
%
%\usepackage{paralist}
%\usepackage{nicefrac}
%% setting the font style for input und returns in description items
%\newcommand{\initem}[2]{\item[\hspace{0.5em} {\normalfont\ttfamily{#1}} {\normalfont\itshape{(#2)}}]}
%\newcommand{\outitem}[1]{\item[\hspace{0.5em} \normalfont\itshape{(#1)}]}
%\newcommand{\bfpara}[1]{
%	
%	\noindent \textbf{#1:}\,}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Generated by Sphinx.
\def\sphinxdocclass{report}

\documentclass[letterpaper,10pt,ngerman, oneside, openright]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[ngerman]{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsngerman{\renewcommand{\contentsname}{Inhalt:}}

\addto\captionsngerman{\renewcommand{\figurename}{Abb.}}
\addto\captionsngerman{\renewcommand{\tablename}{Tab.}}
\addto\captionsngerman{\renewcommand{\literalblockname}{Quellcode}}

\addto\captionsngerman{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsngerman{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasngerman{\def\pageautorefname{Seite}}

\setcounter{tocdepth}{1}



\title{Serie 5 Schnittstellendokumentation}
\date{Abgabe: \today}
\release{}
\author{Arsen Hnatiuk, Max Huneshagen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\pagestyle{plain}
\usepackage{chngcntr}
\counterwithout{equation}{chapter}
\begin{document}

% generating the title page
\maketitle
% generating the table of contents (requires to run pdflatex twice!)
\tableofcontents
\bigskip

\hrule
\hrule

%%% BEGIN OF CONTENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Einleitung}

%\section{Laplace Gleichung}
Die in dieser Serie implementierten Programme ermöglichen die Lösung des in Serie 2 betrachteten Gleichungssystems
\begin{align}
A^{(d)}\hat{u} = b,
\label{eq:glc}
\end{align}
wobei $A^{(d)}$ eine Bandmatrix der Dimension $d$ und $\hat{u}$ eine Approximation der Lösung der Laplace-Gleichung

\begin{align}
\begin{split}
-\Delta u&=f(x)\text{ in }\Omega=(0, 1)^d, d\in\{1,2,3\}\\
u \vert _{\partial\Omega}&=u_D\text{ für ein gegebenes }u_D.
\end{split}
\label{eq:rwp}
\end{align}


ist. $b$ ist der Vektor der Randbedingungen und der Werte der in der Laplace Gleichung gegebenen Funktion $f$ auf den in Serie 2 ausgewählten Punkten. Da alle Randbedingungen in dieser Serie $0$ sind, ist $b$ einfach der Vektor der $f_i := f(x_i)$ für die ausgewählten $x_i$. 

Die Lösung dieses Systems erfolgt durch die L-U-Zerlegung der $A^{(d)}$ Matrix. Wir können also $TA^{(d)}=LU$ für eine Permutationsmatrix $P$, eine unipotente untere Dreiecksmatrix $L$ und eine invertierbare obere Dreiecksmatrix $U$ schreiben. Dann lässt sich die Gleichung \ref{eq:glc} so darstellen:
\begin{align}
T^tLU\hat{u}=b
\label{eq:lu}
\end{align}
Man gewinnt die Werte von $\hat{u}$, indem man mittels Rückwärtssubstitution die Gleichung 
\begin{align}
T^tLz=b
\label{eq:lu1}
\end{align}
für ein $z\in \mathbb{R}^{(n-1)^d}$ löst. Dies ist möglich, weil $L$ eine Dreiecksmatrix mit Einsen auf der Hauptdiagonale ist. Die Werte von $\hat{u}$ rechnet man durch Rückwärtssubstitution in der Gleichung \eqref{eq:lu2} aus. Dies ist möglich, weil alle Hauptdiagonaleinträge von $R$ ungleich $0$ sind (dies sind die sogenannten Pivotelemente).
\begin{align}
R\hat{u}=z
\label{eq:lu2}
\end{align}
Wenn man die Gleichungen \eqref{eq:lu1} und \eqref{eq:lu2} zusammensetzt, so erhält man \eqref{eq:lu}.

Zusätzlich wurde in dieser Serie eine Methode zur Lösung des Gleichungssystems \eqref{eq:glc} mit Hilfe des \emph{conjugate gradients}-Verfahrens implementiert. Dieses Verfahren wird in der Praxis nahezu ausschließlich als iteratives Verfahren verwendet, obwohl es sich eigentlich um ein direktes Verfahren handelt. Der Algorithmus ist im Bericht zu dieser Serie dargestellt.

%%%%%% HILBERT-MATRIZEN
%\section{Hilbert-Matrizen}
%Die erstellten Programme ermöglichen auch die Arbeit mit Hilbert-Matrizen. Diese dienen als Beispiel schlecht konditionierter Matrizen und sind wie folgt definiert:
%\begin{align}
%H_m &:= (a_{ij})_{1\le i, j \le m} \in \mathbb{R}^{m\times m}, 	\\
%a_{ij} &:= \frac{1}{i+j-1} \label{eq:hb1}
%\end{align}
%Das Inverse einer Hilbert-Matrix ergibt sich zu:
%\begin{align}
%H_m^{-1}& := (b_{ij})_{1\le i, j \le m} \in \mathbb{R}^{m\times m},	\\
%b_{ij} := \frac{(-1)^{i+j}}{i+j-1}\cdot &\frac{(m+i-1)!}{(i-1)!^2(m-i)!}\cdot \frac{(m+j-1)!}{(j-1)!^2(m-j)!}
%\end{align}
%
%Für die Kondition $\kappa$ einer Matrix $A$ gilt
%\begin{align}
%\kappa(A)=\|A\|\cdot \|A^{-1}\|
%\end{align}
%Wenn wir die Spaltensummennorm $\|\cdot \|_{\infty}$ benutzen, ist die hohe Kondition einer Hilbert-Matrix leicht zu sehen. Aus \eqref{eq:hb1}  sieht man, dass die erste Spalte von $H_m$ die höchste Spaltensumme hat, und es gilt
%\begin{align}
%\|H_m\|_{\infty}=\sum_{i=1}^{m}\frac{1}{i}
%\end{align}
%Diese Reihe divergiert. Die Einträge von $H_m^{-1}$ sind dabei sehr groß. Schon für $i=j=1$ gilt $b_{ij} = m^2$, also wächst die Norm von dieser Matrix mindestens quadratisch. Folglich ist die Kondition $\kappa(H_m)\gg1$ für $m>1$.


\chapter{Die erweiterte Sparse-Klasse}

\label{\detokenize{index:welcome-to-serie-3-s-documentation}}\label{\detokenize{index:module-sparse_erw}}\label{\detokenize{index:die-sparse-klasse}}\index{sparse\_erw (Modul)}
\textit{sparse\_erw.py} stellt eine erweiterte Version der  Klasse \textit{Sparse} zur Verfügung, mit der die Matrix $A^{(d)}$ für $d\in\{1,2,3\}$
bestimmt und analysiert werden kann.
\index{Sparse (Klasse in sparse\_erw)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{sparse\_erw.}\sphinxbfcode{Sparse}}{\emph{dim}, \emph{dis}, \emph{r\_s=None}, \emph{ex\_lsg=None}}{}
Diese Klasse erlaubt das Erstellen der Matrizen $A^{(d)}$ für $d \in \{1,2,3\}$. Diese Matrizen werden
z. B. für die Berechnung der DGL $u''(x)=-f(x)$ verwendet. Es handelt sich bei diesen Matrizen
um sehr dünn besetzte Block-Band-Matrizen, was die Verwendung von sog. sparse-Matrizen
in der numerischen Umsetzung nahelegt.

Attribute:
\begin{quote}
\begin{description}
\item[{dim (int):}] \leavevmode
Raumdimension des zu untersuchenden Gebietes.

\item[{dis (numpy.ndarray aus floats):}] \leavevmode
Maß für die Diskretisierung des zu untersuchenden Gebietes.

\item[{matr (scipy.dok\_matrix-Objekt):}] \leavevmode
$A^{(d)}$ mit Diskretisierung dis.

\end{description}
\end{quote}
\index{anz\_n\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_abs}}{}{}
Gibt die Anzahl von Einträgen von $A^{(d)}$ zurück, die gleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}

\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Anzahl von Nulleinträgen von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_n\_lu\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_lu_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_lu\_abs}}{}{}
Gibt die Anzahl von Einträgen von $L$ bzw. $U$ zurück, die gleich $0$ sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Anzahl von Nulleinträgen von $L$ und $U$.

\end{description}

\end{description}

\end{fulllineitems}
\clearpage
\index{anz\_n\_lu\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_lu_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_lu\_rel}}{}{}
Gibt die relative Anzahl von Einträgen von L bzw. U zurück, die gleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Relative Anzahl von Nulleinträgen von $L$ und $U$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_n\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_n_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_n\_rel}}{}{}
Gibt die relative Anzahl von Einträgen von $A^{(d)}$ zurück, die gleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Relative Anzahl von Nulleinträgen von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_abs}}{}{}
Gibt die Anzahl von Einträgen von $A^{(d)}$ zurück, die ungleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Anzahl von Nichtnulleinträgen von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_lu\_abs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_lu_abs}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_lu\_abs}}{}{}
Gibt die Anzahl von Einträgen von L bzw. U zurück, die ungleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Anzahl von Nichtnulleinträgen von $L$ und $U$.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_lu\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_lu_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_lu\_rel}}{}{}
Gibt die relative Anzahl von Einträgen von L bzw. U zurück, die ungleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int-Tupel):}] \leavevmode
Relative Anzahl von Nulleinträgen von L und U.

\end{description}

\end{description}

\end{fulllineitems}

\index{anz\_nn\_rel() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.anz_nn_rel}}\pysiglinewithargsret{\sphinxbfcode{anz\_nn\_rel}}{}{}
Gibt die relative Anzahl von Einträgen von $A^{(d)}$ zurück, die ungleich 0 sind.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Relative Anzahl von Nulleinträgen von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}
\clearpage
\index{constr\_mat\_l\_k() (Methode von sparse\_erw.Sparse)}

\index{cg\_meth() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.cg_meth}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cg\_meth}}}{\emph{los1}, \emph{vekb}, \emph{eps}}{}
Diese Methode approximiert die Lösung eines Gleichungssystems mithilfe des CG-Verfahrens
bis auf eine vorgegebene Genauigkeit.

\begin{description}
\item [{Input:}] 
\end{description}
\begin{quote}
\begin{description}
\item[{los0 (numpy.ndarray):}] \leavevmode
Startwert $x_0$ der Iteration.

\item[{vekb (numpy.ndarrays):}] \leavevmode
Rechte Seite $b$ des zu lösenden Gleichungssystems.

\item[{eps (float):}] \leavevmode
Grenze für das Abbruchkriterium. Das Verfahren wird abgebrochen, wenn für das Residuum gilt: $\|r_{k+1}\|_\infty<eps$.

\end{description}
\end{quote}

\begin{description}
\item [{Return:}] 
\end{description}
\begin{quote}
\begin{description}
\item[{los (Liste aus numpy.ndarray aus floats):}] \leavevmode
Liste mit den berechneten Lösungen nach jedem Iterationsschitt

\end{description}
\end{quote}

\end{fulllineitems}


\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.constr_mat_l_k}}\pysiglinewithargsret{\sphinxbfcode{constr\_mat\_l\_k}}{\emph{k}, \emph{dim}, \emph{dis}}{}
Konstruiert die Matrix $A_l(k)$ mit der gewünschten Diskretisierung.

\begin{description}
\item [{Input:}] \leavevmode

\begin{quote}
\begin{description}
\item[{k (float):}] \leavevmode
Bestimmt den Wert auf der Hauptdiagonalen der untersuchten Matrix (=2*k)

\item[{dim (int, mögliche Werte: 1, 2, 3):}] \leavevmode
Raumdimension des betrachteten Gebietes.

\item[{dis (int):}] \leavevmode
Diskretisierung des Gebietes.

\end{description}
\end{quote}
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
A\_l(k) mit der gewuenschten Diskretisierung.

\end{description}

\end{description}

\end{fulllineitems}

\index{kond\_a\_d\_zs() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.kond_a_d_zs}}\pysiglinewithargsret{\sphinxbfcode{kond\_a\_d\_zs}}{}{}
Gibt die Kondition der Matrix $A^{(d)}$ bezüglich der Zeilensummennorm zurück.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Kondition von $A^{(d)}$ bzgl. Zeilennorm.

\end{description}

\end{description}

\end{fulllineitems}

\index{l\_u\_zerl() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.l_u_zerl}}\pysiglinewithargsret{\sphinxbfcode{l\_u\_zerl}}{}{}
Errechnet die L-U-Zerlegung von $A^{(d)}=P_r^TLUP_c^T$.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(list):}] \leavevmode
Nullter Eintrag: das mit der Zerlegung korrespondierende \textit{scipy.SuperLU}-Objekt.
Erster Eintrag: Tripel aus den Matrizen $P_r$, $P_c$, $L$, $U$.

\end{description}

\end{description}

\end{fulllineitems}

\index{lgs\_lsg() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.lgs_lsg}}\pysiglinewithargsret{\sphinxbfcode{lgs\_lsg}}{\emph{r\_s=None}}{}~%\begin{quote}

Löst das Gleichungssystem Ax=r\_s für eine vorgebene rechte Seite unter Ausnutzung der
Dreieckszerlegung.

\begin{description}
\item [{Input:}]

\begin{quote}
\begin{description}
\item[{r\_s (numpy.ndarray):}] \leavevmode
rechte Seite b des zu lösenden Gleichungssystems $A^{(d)}$*x=b.

\end{description}
\end{quote}\end{description}
%\end{quote}

\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(numpy.ndarray):}] \leavevmode
Lösungsvektor.

\end{description}

\end{description}

\end{fulllineitems}

\index{return\_mat\_d() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d}}{}{}
Diese Methode gibt die Matrix $A^{(d)}$ as sparse-Matrix zurück.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
Die Matrix $A^{(d)}$ als sparse-Matrix.

\end{description}

\end{description}

\end{fulllineitems}
\index{return\_mat\_d\_csc() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d_csc}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d\_csc}}{}{}
Gibt $A^{(d)}$ als scipy.sparse.csc\_matrix-Objekt zurück.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.csc\_matrix-Objekt)}] \leavevmode
Die Matrix $A^{(d)}$

\end{description}

\end{description}

\end{fulllineitems}

\index{return\_mat\_d\_inv() (Methode von sparse\_erw.Sparse)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sparse_erw.Sparse.return_mat_d_inv}}\pysiglinewithargsret{\sphinxbfcode{return\_mat\_d\_inv}}{}{}
Gibt die numerisch berechnete Inverse von $A^{(d)}$ zurück.

\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(scipy.sparse.dok\_matrix-Objekt):}] \leavevmode
Inverse von $A^{(d)}$.

\end{description}

\end{description}

\end{fulllineitems}


\end{fulllineitems}

%\section{Die Hilbert-Klasse}
%
%\phantomsection\label{\detokenize{index:module-hilbertmatr}}\index{hilbertmatr (Modul)}
%\textit{hilbertmatr.py} stellt die Klasse Hilbert zur Verfügung, mit der die Hilbertmatrix bestimmt und
%analysiert werden kann.
%\index{Hilbert (Klasse in hilbertmatr)}
%
%\begin{fulllineitems}
%\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{hilbertmatr.}\sphinxbfcode{Hilbert}}{\emph{dim}, \emph{r\_s=None}}{}
%Diese Klasse stellt Hilbert-Matrizen zur Verfügung.
%
%Attribute:
%\begin{quote}
%\begin{description}
%\item[{dim (int):}] \leavevmode
%Dimension der Matrix.
%
%\end{description}
%\end{quote}
%\index{kond\_hil\_zs() (Methode von hilbertmatr.Hilbert)}
%
%\begin{fulllineitems}
%\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert.kond_hil_zs}}\pysiglinewithargsret{\sphinxbfcode{kond\_hil\_zs}}{}{}
%Gibt die Kondition der Matrix bezüglich der Zeilensummennorm zurueck.
%
%\begin{description}
%\item [{Input:}] -
%\end{description}
%\begin{description}
%\item[{Return:}] \leavevmode\begin{description}
%\item[{(float):}] \leavevmode
%Kondition der Hilbertmatrix.
%
%\end{description}
%
%\end{description}
%
%\end{fulllineitems}
%
%\index{l\_u\_zerl() (Methode von hilbertmatr.Hilbert)}
%
%\begin{fulllineitems}
%\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert.l_u_zerl}}\pysiglinewithargsret{\sphinxbfcode{l\_u\_zerl}}{}{}
%Errechnet die L-U-Zerlegung von $H_m=PLU$.
%
%\begin{description}
%\item [{Input:}] -
%\end{description}
%\begin{description}
%\item[{Return:}] \leavevmode\begin{description}
%\item[{(Tripel aus numpy.ndarrays):}] \leavevmode
%Die Matrizen $P$, $L$, $U$.
%
%\end{description}
%
%\end{description}
%
%\end{fulllineitems}
%
%\index{lgs\_lsg() (Methode von hilbertmatr.Hilbert)}
%
%\begin{fulllineitems}
%\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert.lgs_lsg}}\pysiglinewithargsret{\sphinxbfcode{lgs\_lsg}}{\emph{r\_s=None}}{}
%Löst das Gleichungssystem $H_mx=r\_s$ für eine vorgebene rechte Seite unter Ausnutzung der
%Dreieckszerlegung.
%
%\begin{description}
%\item [{Input:}] -
%\end{description}
%\begin{description}
%\item[{Return:}] \leavevmode\begin{description}
%\item[{(numpy.ndarray)}] \leavevmode
%rechte Seite des Gleichungssystems $H_mx=r\_s$.
%
%\end{description}\end{description}
%
%\end{fulllineitems}
%
%\index{return\_hil\_matr() (Methode von hilbertmatr.Hilbert)}
%
%\begin{fulllineitems}
%\phantomsection\label{\detokenize{index:hilbertmatr.Hilbert.return_hil_matr}}\pysiglinewithargsret{\sphinxbfcode{return\_hil\_matr}}{\emph{inv=\texttt{False}}}{}
%Gibt die Hilbertmatrix oder ihr Inverses zurück.
%\begin{description}
%\item [{Input:}] \leavevmode
%
%
%
%\begin{description}
%\item[{inv (bool, Standard: False)}] \leavevmode
%Gibt an, ob Hilbertmatrix (\texttt{False}) oder ihr Inverses (\texttt{True}) ausgegeben wird.
%\end{description}
%
%\end{description}
%\begin{description}
%\item[{Return:}] \leavevmode\begin{description}
%\item[{(numpy.ndarray):}] \leavevmode
%Hilbertmatrix oder ihr Inverses, falls \texttt{inv == True}.
%
%\end{description}
%
%\end{description}
%
%\end{fulllineitems}
%
%
%\end{fulllineitems}




\chapter{Das Skript aufg\_5-2.py}
\label{\detokenize{index:module-aufg_5_2}}\label{\detokenize{index:das-skript-aufg-5-2-py}}\index{aufg\_5\_2 (Modul)}
Dieses Modul löst die Aufgabe 5.2, indem es die Differentialgleichung löst und
das Verhalten der Lösungen graphisch darstellt.
\index{fntn1() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.fntn1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{fntn1}}}{\emph{wert}}{}
Beispielfunktion der Dimension 1.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{wert (float):}] \leavevmode
Stelle, an  der die Funktion ausgewertet wird.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Wert der Funktion an der gegebenen Stelle.

\end{description}

\end{description}

\end{fulllineitems}

\index{fntn2() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.fntn2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{fntn2}}}{\emph{wert}}{}
Beispielfunktion der Dimension 2.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{wert (array von float):}] \leavevmode
Stelle im $\mathbb{R}^2$, an der die Funktion ausgewertet wird.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Wert der Funktion an der gegebenen Stelle.

\end{description}

\end{description}

\end{fulllineitems}

\index{fntn3() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.fntn3}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{fntn3}}}{\emph{wert}}{}
Beispielfunktion der Dimension 3.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{wert (array von float):}] \leavevmode
Stelle im $\mathbb{R}^3$, an der die Funktion ausgewertet wird.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Wert der Funktion an der gegebenen Stelle.

\end{description}

\end{description}

\end{fulllineitems}

\index{gitter() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.gitter}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{gitter}}}{\emph{numb}, \emph{dims}}{}
Funktion, die für eine gegebene Dimension und Schritweite eine Menge von Punkten erzeugt, auf
der die Differentialgleichung zu loesen ist.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{numb (int):}] \leavevmode
Feinheit der Diskretisierung.

\item[{dims (int):}] \leavevmode
Dimension der Diskretisierung.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{arra (ndarray):}] \leavevmode
Array mit den Punkten des Diskretisierungsgitters.

\end{description}

\end{description}

\end{fulllineitems}

\index{loesg() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.loesg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{loesg}}}{\emph{dims}, \emph{numb}, \emph{fkt}, \emph{ulsg}}{}
Diese Methode dient zur Lösung der Differentialgleichung und zum Vergleichen der exakten
und approxmierten Lösungen.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{dims (int):}] \leavevmode
Dimension der Diskretisierung.

\item[{numb (int):}] \leavevmode
Feinheit der Diskretisierung.

\item[{fkt (Funktion):}] \leavevmode
Die gegebene Funktion $f$ aus der Aufgabestellung.

\item[{ulsg (Funktion):}] \leavevmode
Die exakte Lösung der Differentialgleichung

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Der absolute Fehler in der approximierten Lösung der Differentialgleichung

\end{description}

\end{description}

\end{fulllineitems}

\index{main() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.main}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{main}}}{}{}
In dieser Funktion werden alle Lösungen der Aufgabe dem Nutzer ausgegeben
\begin{description}
\item [{Input:}] -
\end{description}
\begin{description}
\item [{Return:}] .
\end{description}
\end{fulllineitems}

\index{modo() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.modo}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{modo}}}{\emph{m\_nb}, \emph{numb}}{}
Funktion, die die modofizierte Modolo-Methode aus dem Bericht zu Serie 2 implementiert.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{m\_nb (int):}] \leavevmode
Zahl, für die der Wert der modifizierten Modolo Methode berechnet werden soll.

\item[{numb (int):}] \leavevmode
Feinheit der Diskretisierung.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(int):}] \leavevmode
Ausgabe der modifizierten Modolo-Methode.

\end{description}

\end{description}

\end{fulllineitems}

\index{ulsg1() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.ulsg1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{ulsg1}}}{\emph{wert}}{}
Exakte Lösung der Dimension 1.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{wert (float):}] \leavevmode
Stelle, an der die Funktion ausgewertet wird.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Wert der Funktion an der gegebenen Stelle.

\end{description}

\end{description}

\end{fulllineitems}

\index{ulsg2() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.ulsg2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{ulsg2}}}{\emph{wert}}{}
Exakte Lösung der Dimension 2.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{wert (array von float):}] \leavevmode
Stelle im $\mathbb{R}^2$, an der die Funktion ausgewertet wird.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Wert der Funktion an der gegebenen Stelle.

\end{description}

\end{description}

\end{fulllineitems}

\index{ulsg3() (im Modul aufg\_5\_2)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:aufg_5_2.ulsg3}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{aufg\_5\_2.}}\sphinxbfcode{\sphinxupquote{ulsg3}}}{\emph{wert}}{}
Exakte Lösung der Dimension 3.
\begin{description}
\item [{Input:}]
\end{description}
\begin{quote}
\begin{description}
\item[{wert (array von float):}] \leavevmode
Stelle im $\mathbb{R}^3$, an der die Funktion ausgewertet wird.

\end{description}
\end{quote}
\begin{description}
\item[{Return:}] \leavevmode\begin{description}
\item[{(float):}] \leavevmode
Wert der Funktion an dher gegebenen Stelle.

\end{description}

\end{description}

\end{fulllineitems}





%%% END OF DOCUMENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
